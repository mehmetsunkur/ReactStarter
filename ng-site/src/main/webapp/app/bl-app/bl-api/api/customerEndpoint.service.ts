/**
 * Broadleaf Commerce API
 * The default Broadleaf Commerce APIs
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ChangePasswordForm } from '../model/changePasswordForm';
import { CustomerAddressWrapper } from '../model/customerAddressWrapper';
import { CustomerAttributeWrapper } from '../model/customerAttributeWrapper';
import { CustomerPaymentWrapper } from '../model/customerPaymentWrapper';
import { CustomerWrapper } from '../model/customerWrapper';
import { ErrorWrapper } from '../model/errorWrapper';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class CustomerEndpointService {

    protected basePath = 'https://localhost:3000/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * addAddress
     * 
     * @param wrapper wrapper
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addAddressUsingPUT1(wrapper: CustomerAddressWrapper, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerAddressWrapper>;
    public addAddressUsingPUT1(wrapper: CustomerAddressWrapper, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerAddressWrapper>>;
    public addAddressUsingPUT1(wrapper: CustomerAddressWrapper, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerAddressWrapper>>;
    public addAddressUsingPUT1(wrapper: CustomerAddressWrapper, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling addAddressUsingPUT1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling addAddressUsingPUT1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<CustomerAddressWrapper>(`${this.basePath}/customer/address`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addAttribute
     * 
     * @param wrapper wrapper
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addAttributeUsingPUT1(wrapper: CustomerAttributeWrapper, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public addAttributeUsingPUT1(wrapper: CustomerAttributeWrapper, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public addAttributeUsingPUT1(wrapper: CustomerAttributeWrapper, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public addAttributeUsingPUT1(wrapper: CustomerAttributeWrapper, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling addAttributeUsingPUT1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling addAttributeUsingPUT1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<CustomerWrapper>(`${this.basePath}/customer/attribute`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addCustomerPayment
     * 
     * @param wrapper wrapper
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addCustomerPaymentUsingPOST1(wrapper: CustomerPaymentWrapper, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerPaymentWrapper>;
    public addCustomerPaymentUsingPOST1(wrapper: CustomerPaymentWrapper, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerPaymentWrapper>>;
    public addCustomerPaymentUsingPOST1(wrapper: CustomerPaymentWrapper, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerPaymentWrapper>>;
    public addCustomerPaymentUsingPOST1(wrapper: CustomerPaymentWrapper, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling addCustomerPaymentUsingPOST1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling addCustomerPaymentUsingPOST1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CustomerPaymentWrapper>(`${this.basePath}/customer/payment`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addCustomer
     * 
     * @param wrapper wrapper
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addCustomerUsingPOST1(wrapper: CustomerWrapper, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public addCustomerUsingPOST1(wrapper: CustomerWrapper, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public addCustomerUsingPOST1(wrapper: CustomerWrapper, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public addCustomerUsingPOST1(wrapper: CustomerWrapper, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling addCustomerUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CustomerWrapper>(`${this.basePath}/customer`,
            wrapper,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * changePassword
     * 
     * @param changePasswordForm changePasswordForm
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public changePasswordUsingPOST1(changePasswordForm: ChangePasswordForm, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public changePasswordUsingPOST1(changePasswordForm: ChangePasswordForm, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public changePasswordUsingPOST1(changePasswordForm: ChangePasswordForm, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public changePasswordUsingPOST1(changePasswordForm: ChangePasswordForm, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (changePasswordForm === null || changePasswordForm === undefined) {
            throw new Error('Required parameter changePasswordForm was null or undefined when calling changePasswordUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CustomerWrapper>(`${this.basePath}/customer/password`,
            changePasswordForm,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findAddress
     * 
     * @param addressName addressName
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAddressUsingGET1(addressName: string, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerAddressWrapper>;
    public findAddressUsingGET1(addressName: string, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerAddressWrapper>>;
    public findAddressUsingGET1(addressName: string, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerAddressWrapper>>;
    public findAddressUsingGET1(addressName: string, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addressName === null || addressName === undefined) {
            throw new Error('Required parameter addressName was null or undefined when calling findAddressUsingGET1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling findAddressUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addressName !== undefined) {
            queryParameters = queryParameters.set('addressName', <any>addressName);
        }
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CustomerAddressWrapper>(`${this.basePath}/customer/address`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findAllAddresses
     * 
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAllAddressesUsingGET1(customerId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<CustomerAddressWrapper>>;
    public findAllAddressesUsingGET1(customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CustomerAddressWrapper>>>;
    public findAllAddressesUsingGET1(customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CustomerAddressWrapper>>>;
    public findAllAddressesUsingGET1(customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling findAllAddressesUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CustomerAddressWrapper>>(`${this.basePath}/customer/addresses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findAllCustomerPayments
     * 
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAllCustomerPaymentsUsingGET1(customerId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<CustomerPaymentWrapper>>;
    public findAllCustomerPaymentsUsingGET1(customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CustomerPaymentWrapper>>>;
    public findAllCustomerPaymentsUsingGET1(customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CustomerPaymentWrapper>>>;
    public findAllCustomerPaymentsUsingGET1(customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling findAllCustomerPaymentsUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CustomerPaymentWrapper>>(`${this.basePath}/customer/payments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findCustomerByEmail
     * 
     * @param email email
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCustomerByEmailUsingGET1(email: string, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public findCustomerByEmailUsingGET1(email: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public findCustomerByEmailUsingGET1(email: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public findCustomerByEmailUsingGET1(email: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling findCustomerByEmailUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CustomerWrapper>(`${this.basePath}/customer`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findCustomerPayment
     * 
     * @param paymentId paymentId
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCustomerPaymentUsingGET1(paymentId: number, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerPaymentWrapper>;
    public findCustomerPaymentUsingGET1(paymentId: number, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerPaymentWrapper>>;
    public findCustomerPaymentUsingGET1(paymentId: number, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerPaymentWrapper>>;
    public findCustomerPaymentUsingGET1(paymentId: number, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling findCustomerPaymentUsingGET1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling findCustomerPaymentUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (paymentId !== undefined) {
            queryParameters = queryParameters.set('paymentId', <any>paymentId);
        }
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CustomerPaymentWrapper>(`${this.basePath}/customer/payment`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeAddress
     * 
     * @param addressName addressName
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAddressUsingDELETE1(addressName: string, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<CustomerAddressWrapper>>;
    public removeAddressUsingDELETE1(addressName: string, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CustomerAddressWrapper>>>;
    public removeAddressUsingDELETE1(addressName: string, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CustomerAddressWrapper>>>;
    public removeAddressUsingDELETE1(addressName: string, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addressName === null || addressName === undefined) {
            throw new Error('Required parameter addressName was null or undefined when calling removeAddressUsingDELETE1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeAddressUsingDELETE1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<Array<CustomerAddressWrapper>>(`${this.basePath}/customer/address/${encodeURIComponent(String(addressName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeAllAddresses
     * 
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAllAddressesUsingDELETE1(customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public removeAllAddressesUsingDELETE1(customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public removeAllAddressesUsingDELETE1(customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public removeAllAddressesUsingDELETE1(customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeAllAddressesUsingDELETE1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<CustomerWrapper>(`${this.basePath}/customer/addresses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeAllAttributes
     * 
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAllAttributesUsingDELETE1(customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public removeAllAttributesUsingDELETE1(customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public removeAllAttributesUsingDELETE1(customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public removeAllAttributesUsingDELETE1(customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeAllAttributesUsingDELETE1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<CustomerWrapper>(`${this.basePath}/customer/attributes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeAllCustomerPayments
     * 
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAllCustomerPaymentsUsingDELETE1(customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public removeAllCustomerPaymentsUsingDELETE1(customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public removeAllCustomerPaymentsUsingDELETE1(customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public removeAllCustomerPaymentsUsingDELETE1(customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeAllCustomerPaymentsUsingDELETE1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<CustomerWrapper>(`${this.basePath}/customer/payments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeAttribute
     * 
     * @param attributeName attributeName
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAttributeUsingDELETE1(attributeName: string, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public removeAttributeUsingDELETE1(attributeName: string, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public removeAttributeUsingDELETE1(attributeName: string, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public removeAttributeUsingDELETE1(attributeName: string, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling removeAttributeUsingDELETE1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeAttributeUsingDELETE1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<CustomerWrapper>(`${this.basePath}/customer/attribute/${encodeURIComponent(String(attributeName))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeCustomerPayment
     * 
     * @param paymentId paymentId
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeCustomerPaymentUsingDELETE1(paymentId: number, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<CustomerPaymentWrapper>>;
    public removeCustomerPaymentUsingDELETE1(paymentId: number, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CustomerPaymentWrapper>>>;
    public removeCustomerPaymentUsingDELETE1(paymentId: number, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CustomerPaymentWrapper>>>;
    public removeCustomerPaymentUsingDELETE1(paymentId: number, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling removeCustomerPaymentUsingDELETE1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling removeCustomerPaymentUsingDELETE1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<Array<CustomerPaymentWrapper>>(`${this.basePath}/customer/payment/${encodeURIComponent(String(paymentId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateAddress
     * 
     * @param addressId addressId
     * @param wrapper wrapper
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateAddressUsingPUT1(addressId: number, wrapper: CustomerAddressWrapper, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerAddressWrapper>;
    public updateAddressUsingPUT1(addressId: number, wrapper: CustomerAddressWrapper, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerAddressWrapper>>;
    public updateAddressUsingPUT1(addressId: number, wrapper: CustomerAddressWrapper, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerAddressWrapper>>;
    public updateAddressUsingPUT1(addressId: number, wrapper: CustomerAddressWrapper, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addressId === null || addressId === undefined) {
            throw new Error('Required parameter addressId was null or undefined when calling updateAddressUsingPUT1.');
        }
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling updateAddressUsingPUT1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateAddressUsingPUT1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<CustomerAddressWrapper>(`${this.basePath}/customer/address/${encodeURIComponent(String(addressId))}`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateCustomerPayment
     * 
     * @param paymentId paymentId
     * @param wrapper wrapper
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateCustomerPaymentUsingPUT1(paymentId: number, wrapper: CustomerPaymentWrapper, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerPaymentWrapper>;
    public updateCustomerPaymentUsingPUT1(paymentId: number, wrapper: CustomerPaymentWrapper, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerPaymentWrapper>>;
    public updateCustomerPaymentUsingPUT1(paymentId: number, wrapper: CustomerPaymentWrapper, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerPaymentWrapper>>;
    public updateCustomerPaymentUsingPUT1(paymentId: number, wrapper: CustomerPaymentWrapper, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling updateCustomerPaymentUsingPUT1.');
        }
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling updateCustomerPaymentUsingPUT1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomerPaymentUsingPUT1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<CustomerPaymentWrapper>(`${this.basePath}/customer/payment/${encodeURIComponent(String(paymentId))}`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateCustomer
     * 
     * @param wrapper wrapper
     * @param customerId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateCustomerUsingPUT1(wrapper: CustomerWrapper, customerId: number, observe?: 'body', reportProgress?: boolean): Observable<CustomerWrapper>;
    public updateCustomerUsingPUT1(wrapper: CustomerWrapper, customerId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerWrapper>>;
    public updateCustomerUsingPUT1(wrapper: CustomerWrapper, customerId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerWrapper>>;
    public updateCustomerUsingPUT1(wrapper: CustomerWrapper, customerId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling updateCustomerUsingPUT1.');
        }
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomerUsingPUT1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerId !== undefined) {
            queryParameters = queryParameters.set('customerId', <any>customerId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<CustomerWrapper>(`${this.basePath}/customer`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
