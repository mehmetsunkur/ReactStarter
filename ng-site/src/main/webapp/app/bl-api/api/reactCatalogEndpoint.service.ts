/**
 * Broadleaf Commerce API
 * The default Broadleaf Commerce APIs
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CategoriesWrapper } from '../model/categoriesWrapper';
import { CategoryAttributeWrapper } from '../model/categoryAttributeWrapper';
import { CategoryWrapper } from '../model/categoryWrapper';
import { InventoryWrapper } from '../model/inventoryWrapper';
import { MediaWrapper } from '../model/mediaWrapper';
import { ProductAttributeWrapper } from '../model/productAttributeWrapper';
import { ProductWrapper } from '../model/productWrapper';
import { RelatedProductWrapper } from '../model/relatedProductWrapper';
import { SearchResultsWrapper } from '../model/searchResultsWrapper';
import { SkuAttributeWrapper } from '../model/skuAttributeWrapper';
import { SkuWrapper } from '../model/skuWrapper';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ReactCatalogEndpointService {

    protected basePath = 'https://localhost:3000/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * findActiveSubCategories
     * 
     * @param categoryId categoryId
     * @param limit limit
     * @param offset offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findActiveSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<CategoriesWrapper>;
    public findActiveSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoriesWrapper>>;
    public findActiveSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoriesWrapper>>;
    public findActiveSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling findActiveSubCategoriesUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CategoriesWrapper>(`${this.basePath}/catalog/category/${encodeURIComponent(String(categoryId))}/activeSubcategories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findAllCategories
     * 
     * @param name name
     * @param limit limit
     * @param offset offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAllCategoriesUsingGET3(name?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<CategoriesWrapper>;
    public findAllCategoriesUsingGET3(name?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoriesWrapper>>;
    public findAllCategoriesUsingGET3(name?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoriesWrapper>>;
    public findAllCategoriesUsingGET3(name?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CategoriesWrapper>(`${this.basePath}/catalog/categories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findCategoryAttributesForCategory
     * 
     * @param categoryId categoryId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCategoryAttributesForCategoryUsingGET3(categoryId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<CategoryAttributeWrapper>>;
    public findCategoryAttributesForCategoryUsingGET3(categoryId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CategoryAttributeWrapper>>>;
    public findCategoryAttributesForCategoryUsingGET3(categoryId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CategoryAttributeWrapper>>>;
    public findCategoryAttributesForCategoryUsingGET3(categoryId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling findCategoryAttributesForCategoryUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CategoryAttributeWrapper>>(`${this.basePath}/catalog/category/${encodeURIComponent(String(categoryId))}/attributes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findCategoryByIdOrName
     * 
     * @param searchParameter searchParameter
     * @param productLimit productLimit
     * @param productOffset productOffset
     * @param subcategoryLimit subcategoryLimit
     * @param subcategoryOffset subcategoryOffset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCategoryByIdOrNameUsingGET3(searchParameter: string, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe?: 'body', reportProgress?: boolean): Observable<CategoryWrapper>;
    public findCategoryByIdOrNameUsingGET3(searchParameter: string, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoryWrapper>>;
    public findCategoryByIdOrNameUsingGET3(searchParameter: string, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoryWrapper>>;
    public findCategoryByIdOrNameUsingGET3(searchParameter: string, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (searchParameter === null || searchParameter === undefined) {
            throw new Error('Required parameter searchParameter was null or undefined when calling findCategoryByIdOrNameUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (searchParameter !== undefined) {
            queryParameters = queryParameters.set('searchParameter', <any>searchParameter);
        }
        if (productLimit !== undefined) {
            queryParameters = queryParameters.set('productLimit', <any>productLimit);
        }
        if (productOffset !== undefined) {
            queryParameters = queryParameters.set('productOffset', <any>productOffset);
        }
        if (subcategoryLimit !== undefined) {
            queryParameters = queryParameters.set('subcategoryLimit', <any>subcategoryLimit);
        }
        if (subcategoryOffset !== undefined) {
            queryParameters = queryParameters.set('subcategoryOffset', <any>subcategoryOffset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CategoryWrapper>(`${this.basePath}/catalog/category`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findCategoryById
     * 
     * @param categoryId categoryId
     * @param productLimit productLimit
     * @param productOffset productOffset
     * @param subcategoryLimit subcategoryLimit
     * @param subcategoryOffset subcategoryOffset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCategoryByIdUsingGET3(categoryId: number, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe?: 'body', reportProgress?: boolean): Observable<CategoryWrapper>;
    public findCategoryByIdUsingGET3(categoryId: number, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoryWrapper>>;
    public findCategoryByIdUsingGET3(categoryId: number, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoryWrapper>>;
    public findCategoryByIdUsingGET3(categoryId: number, productLimit?: number, productOffset?: number, subcategoryLimit?: number, subcategoryOffset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling findCategoryByIdUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (productLimit !== undefined) {
            queryParameters = queryParameters.set('productLimit', <any>productLimit);
        }
        if (productOffset !== undefined) {
            queryParameters = queryParameters.set('productOffset', <any>productOffset);
        }
        if (subcategoryLimit !== undefined) {
            queryParameters = queryParameters.set('subcategoryLimit', <any>subcategoryLimit);
        }
        if (subcategoryOffset !== undefined) {
            queryParameters = queryParameters.set('subcategoryOffset', <any>subcategoryOffset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CategoryWrapper>(`${this.basePath}/catalog/category/${encodeURIComponent(String(categoryId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findCrossSaleProductsByProduct
     * 
     * @param productId productId
     * @param limit limit
     * @param offset offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCrossSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RelatedProductWrapper>>;
    public findCrossSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RelatedProductWrapper>>>;
    public findCrossSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RelatedProductWrapper>>>;
    public findCrossSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling findCrossSaleProductsByProductUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RelatedProductWrapper>>(`${this.basePath}/catalog/product/${encodeURIComponent(String(productId))}/crosssale`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findDefaultSkuByProductId
     * 
     * @param productId productId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findDefaultSkuByProductIdUsingGET3(productId: number, observe?: 'body', reportProgress?: boolean): Observable<SkuWrapper>;
    public findDefaultSkuByProductIdUsingGET3(productId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SkuWrapper>>;
    public findDefaultSkuByProductIdUsingGET3(productId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SkuWrapper>>;
    public findDefaultSkuByProductIdUsingGET3(productId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling findDefaultSkuByProductIdUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SkuWrapper>(`${this.basePath}/catalog/product/${encodeURIComponent(String(productId))}/defaultSku`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findInventoryForSkus
     * 
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findInventoryForSkusUsingGET3(id: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<Array<InventoryWrapper>>;
    public findInventoryForSkusUsingGET3(id: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InventoryWrapper>>>;
    public findInventoryForSkusUsingGET3(id: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InventoryWrapper>>>;
    public findInventoryForSkusUsingGET3(id: Array<number>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findInventoryForSkusUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id) {
            id.forEach((element) => {
                queryParameters = queryParameters.append('id', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InventoryWrapper>>(`${this.basePath}/catalog/sku/inventory`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findMediaForCategory
     * 
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findMediaForCategoryUsingGET3(id: number, observe?: 'body', reportProgress?: boolean): Observable<Array<MediaWrapper>>;
    public findMediaForCategoryUsingGET3(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MediaWrapper>>>;
    public findMediaForCategoryUsingGET3(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MediaWrapper>>>;
    public findMediaForCategoryUsingGET3(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findMediaForCategoryUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MediaWrapper>>(`${this.basePath}/catalog/category/${encodeURIComponent(String(id))}/media`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findMediaForProduct
     * 
     * @param productId productId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findMediaForProductUsingGET3(productId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<MediaWrapper>>;
    public findMediaForProductUsingGET3(productId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MediaWrapper>>>;
    public findMediaForProductUsingGET3(productId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MediaWrapper>>>;
    public findMediaForProductUsingGET3(productId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling findMediaForProductUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MediaWrapper>>(`${this.basePath}/catalog/product/${encodeURIComponent(String(productId))}/media`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findMediaForSku
     * 
     * @param skuId skuId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findMediaForSkuUsingGET3(skuId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<MediaWrapper>>;
    public findMediaForSkuUsingGET3(skuId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MediaWrapper>>>;
    public findMediaForSkuUsingGET3(skuId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MediaWrapper>>>;
    public findMediaForSkuUsingGET3(skuId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (skuId === null || skuId === undefined) {
            throw new Error('Required parameter skuId was null or undefined when calling findMediaForSkuUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MediaWrapper>>(`${this.basePath}/catalog/sku/${encodeURIComponent(String(skuId))}/media`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findParentCategoriesForProduct
     * 
     * @param productId productId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findParentCategoriesForProductUsingGET3(productId: number, observe?: 'body', reportProgress?: boolean): Observable<CategoriesWrapper>;
    public findParentCategoriesForProductUsingGET3(productId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoriesWrapper>>;
    public findParentCategoriesForProductUsingGET3(productId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoriesWrapper>>;
    public findParentCategoriesForProductUsingGET3(productId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling findParentCategoriesForProductUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CategoriesWrapper>(`${this.basePath}/catalog/product/${encodeURIComponent(String(productId))}/categories`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findProductAttributesForProduct
     * 
     * @param productId productId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findProductAttributesForProductUsingGET3(productId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ProductAttributeWrapper>>;
    public findProductAttributesForProductUsingGET3(productId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ProductAttributeWrapper>>>;
    public findProductAttributesForProductUsingGET3(productId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ProductAttributeWrapper>>>;
    public findProductAttributesForProductUsingGET3(productId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling findProductAttributesForProductUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ProductAttributeWrapper>>(`${this.basePath}/catalog/product/${encodeURIComponent(String(productId))}/attributes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findProductById
     * 
     * @param id id
     * @param includePromotionMessages includePromotionMessages
     * @param includePriceData includePriceData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findProductByIdUsingGET3(id: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProductWrapper>;
    public findProductByIdUsingGET3(id: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProductWrapper>>;
    public findProductByIdUsingGET3(id: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProductWrapper>>;
    public findProductByIdUsingGET3(id: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findProductByIdUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includePromotionMessages !== undefined) {
            queryParameters = queryParameters.set('includePromotionMessages', <any>includePromotionMessages);
        }
        if (includePriceData !== undefined) {
            queryParameters = queryParameters.set('includePriceData', <any>includePriceData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ProductWrapper>(`${this.basePath}/catalog/product/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findProductByUrl
     * 
     * @param category category
     * @param product product
     * @param includePromotionMessages includePromotionMessages
     * @param includePriceData includePriceData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findProductByUrlUsingGET1(category: string, product: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProductWrapper>;
    public findProductByUrlUsingGET1(category: string, product: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProductWrapper>>;
    public findProductByUrlUsingGET1(category: string, product: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProductWrapper>>;
    public findProductByUrlUsingGET1(category: string, product: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling findProductByUrlUsingGET1.');
        }
        if (product === null || product === undefined) {
            throw new Error('Required parameter product was null or undefined when calling findProductByUrlUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includePromotionMessages !== undefined) {
            queryParameters = queryParameters.set('includePromotionMessages', <any>includePromotionMessages);
        }
        if (includePriceData !== undefined) {
            queryParameters = queryParameters.set('includePriceData', <any>includePriceData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ProductWrapper>(`${this.basePath}/catalog/product/${encodeURIComponent(String(category))}/${encodeURIComponent(String(product))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findProductsByIds
     * 
     * @param id id
     * @param includePromotionMessages includePromotionMessages
     * @param includePriceData includePriceData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findProductsByIdsUsingGET1(id: Array<number>, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<ProductWrapper>>;
    public findProductsByIdsUsingGET1(id: Array<number>, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ProductWrapper>>>;
    public findProductsByIdsUsingGET1(id: Array<number>, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ProductWrapper>>>;
    public findProductsByIdsUsingGET1(id: Array<number>, includePromotionMessages?: boolean, includePriceData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findProductsByIdsUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id) {
            id.forEach((element) => {
                queryParameters = queryParameters.append('id', <any>element);
            })
        }
        if (includePromotionMessages !== undefined) {
            queryParameters = queryParameters.set('includePromotionMessages', <any>includePromotionMessages);
        }
        if (includePriceData !== undefined) {
            queryParameters = queryParameters.set('includePriceData', <any>includePriceData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ProductWrapper>>(`${this.basePath}/catalog/product`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findSearchResultsByCategoryAndQuery
     * 
     * @param categoryId categoryId
     * @param q q
     * @param pageSize pageSize
     * @param page page
     * @param includePromotionMessages includePromotionMessages
     * @param includePriceData includePriceData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSearchResultsByCategoryAndQueryUsingGET3(categoryId: number, q?: string, pageSize?: number, page?: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<SearchResultsWrapper>;
    public findSearchResultsByCategoryAndQueryUsingGET3(categoryId: number, q?: string, pageSize?: number, page?: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchResultsWrapper>>;
    public findSearchResultsByCategoryAndQueryUsingGET3(categoryId: number, q?: string, pageSize?: number, page?: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchResultsWrapper>>;
    public findSearchResultsByCategoryAndQueryUsingGET3(categoryId: number, q?: string, pageSize?: number, page?: number, includePromotionMessages?: boolean, includePriceData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling findSearchResultsByCategoryAndQueryUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (q !== undefined) {
            queryParameters = queryParameters.set('q', <any>q);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (includePromotionMessages !== undefined) {
            queryParameters = queryParameters.set('includePromotionMessages', <any>includePromotionMessages);
        }
        if (includePriceData !== undefined) {
            queryParameters = queryParameters.set('includePriceData', <any>includePriceData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SearchResultsWrapper>(`${this.basePath}/catalog/search/category/${encodeURIComponent(String(categoryId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findSearchResultsByQuery
     * 
     * @param q q
     * @param pageSize pageSize
     * @param page page
     * @param category category
     * @param includePromotionMessages includePromotionMessages
     * @param includePriceData includePriceData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSearchResultsByQueryUsingGET3(q: string, pageSize?: number, page?: number, category?: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<SearchResultsWrapper>;
    public findSearchResultsByQueryUsingGET3(q: string, pageSize?: number, page?: number, category?: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchResultsWrapper>>;
    public findSearchResultsByQueryUsingGET3(q: string, pageSize?: number, page?: number, category?: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchResultsWrapper>>;
    public findSearchResultsByQueryUsingGET3(q: string, pageSize?: number, page?: number, category?: string, includePromotionMessages?: boolean, includePriceData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling findSearchResultsByQueryUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (q !== undefined) {
            queryParameters = queryParameters.set('q', <any>q);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (category !== undefined) {
            queryParameters = queryParameters.set('category', <any>category);
        }
        if (includePromotionMessages !== undefined) {
            queryParameters = queryParameters.set('includePromotionMessages', <any>includePromotionMessages);
        }
        if (includePriceData !== undefined) {
            queryParameters = queryParameters.set('includePriceData', <any>includePriceData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SearchResultsWrapper>(`${this.basePath}/catalog/search`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findSkuAttributesForSku
     * 
     * @param skuId skuId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSkuAttributesForSkuUsingGET3(skuId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SkuAttributeWrapper>>;
    public findSkuAttributesForSkuUsingGET3(skuId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SkuAttributeWrapper>>>;
    public findSkuAttributesForSkuUsingGET3(skuId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SkuAttributeWrapper>>>;
    public findSkuAttributesForSkuUsingGET3(skuId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (skuId === null || skuId === undefined) {
            throw new Error('Required parameter skuId was null or undefined when calling findSkuAttributesForSkuUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<SkuAttributeWrapper>>(`${this.basePath}/catalog/sku/${encodeURIComponent(String(skuId))}/attributes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findSkuById
     * 
     * @param skuId skuId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSkuByIdUsingGET3(skuId: number, observe?: 'body', reportProgress?: boolean): Observable<SkuWrapper>;
    public findSkuByIdUsingGET3(skuId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SkuWrapper>>;
    public findSkuByIdUsingGET3(skuId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SkuWrapper>>;
    public findSkuByIdUsingGET3(skuId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (skuId === null || skuId === undefined) {
            throw new Error('Required parameter skuId was null or undefined when calling findSkuByIdUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SkuWrapper>(`${this.basePath}/catalog/sku/${encodeURIComponent(String(skuId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findSkusByProductById
     * 
     * @param productId productId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSkusByProductByIdUsingGET3(productId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SkuWrapper>>;
    public findSkusByProductByIdUsingGET3(productId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SkuWrapper>>>;
    public findSkusByProductByIdUsingGET3(productId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SkuWrapper>>>;
    public findSkusByProductByIdUsingGET3(productId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling findSkusByProductByIdUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<SkuWrapper>>(`${this.basePath}/catalog/product/${encodeURIComponent(String(productId))}/skus`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findSubCategories
     * 
     * @param categoryId categoryId
     * @param limit limit
     * @param offset offset
     * @param active active
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, active?: boolean, observe?: 'body', reportProgress?: boolean): Observable<CategoriesWrapper>;
    public findSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, active?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoriesWrapper>>;
    public findSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, active?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoriesWrapper>>;
    public findSubCategoriesUsingGET3(categoryId: number, limit?: number, offset?: number, active?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling findSubCategoriesUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<CategoriesWrapper>(`${this.basePath}/catalog/category/${encodeURIComponent(String(categoryId))}/categories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findUpSaleProductsByProduct
     * 
     * @param productId productId
     * @param limit limit
     * @param offset offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findUpSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RelatedProductWrapper>>;
    public findUpSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RelatedProductWrapper>>>;
    public findUpSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RelatedProductWrapper>>>;
    public findUpSaleProductsByProductUsingGET3(productId: number, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling findUpSaleProductsByProductUsingGET3.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RelatedProductWrapper>>(`${this.basePath}/catalog/product/${encodeURIComponent(String(productId))}/upsale`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
