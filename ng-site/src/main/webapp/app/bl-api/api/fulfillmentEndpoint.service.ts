/**
 * Broadleaf Commerce API
 * The default Broadleaf Commerce APIs
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { AddressWrapper } from '../model/addressWrapper';
import { FulfillmentEstimationWrapper } from '../model/fulfillmentEstimationWrapper';
import { FulfillmentGroupItemWrapper } from '../model/fulfillmentGroupItemWrapper';
import { FulfillmentGroupWrapper } from '../model/fulfillmentGroupWrapper';
import { FulfillmentOptionWrapper } from '../model/fulfillmentOptionWrapper';
import { OrderWrapper } from '../model/orderWrapper';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class FulfillmentEndpointService {

    protected basePath = 'https://localhost:3000/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * addFulfillmentGroupToOrder
     * 
     * @param wrapper wrapper
     * @param cartId cartId
     * @param priceOrder priceOrder
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addFulfillmentGroupToOrderUsingPOST1(wrapper: FulfillmentGroupWrapper, cartId: number, priceOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FulfillmentGroupWrapper>;
    public addFulfillmentGroupToOrderUsingPOST1(wrapper: FulfillmentGroupWrapper, cartId: number, priceOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FulfillmentGroupWrapper>>;
    public addFulfillmentGroupToOrderUsingPOST1(wrapper: FulfillmentGroupWrapper, cartId: number, priceOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FulfillmentGroupWrapper>>;
    public addFulfillmentGroupToOrderUsingPOST1(wrapper: FulfillmentGroupWrapper, cartId: number, priceOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling addFulfillmentGroupToOrderUsingPOST1.');
        }
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling addFulfillmentGroupToOrderUsingPOST1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (priceOrder !== undefined) {
            queryParameters = queryParameters.set('priceOrder', <any>priceOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<FulfillmentGroupWrapper>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/group`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addFulfillmentOptionToFulfillmentGroup
     * 
     * @param fulfillmentGroupId fulfillmentGroupId
     * @param fulfillmentOptionId fulfillmentOptionId
     * @param cartId cartId
     * @param priceOrder priceOrder
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addFulfillmentOptionToFulfillmentGroupUsingPUT1(fulfillmentGroupId: number, fulfillmentOptionId: number, cartId: number, priceOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FulfillmentGroupWrapper>;
    public addFulfillmentOptionToFulfillmentGroupUsingPUT1(fulfillmentGroupId: number, fulfillmentOptionId: number, cartId: number, priceOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FulfillmentGroupWrapper>>;
    public addFulfillmentOptionToFulfillmentGroupUsingPUT1(fulfillmentGroupId: number, fulfillmentOptionId: number, cartId: number, priceOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FulfillmentGroupWrapper>>;
    public addFulfillmentOptionToFulfillmentGroupUsingPUT1(fulfillmentGroupId: number, fulfillmentOptionId: number, cartId: number, priceOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fulfillmentGroupId === null || fulfillmentGroupId === undefined) {
            throw new Error('Required parameter fulfillmentGroupId was null or undefined when calling addFulfillmentOptionToFulfillmentGroupUsingPUT1.');
        }
        if (fulfillmentOptionId === null || fulfillmentOptionId === undefined) {
            throw new Error('Required parameter fulfillmentOptionId was null or undefined when calling addFulfillmentOptionToFulfillmentGroupUsingPUT1.');
        }
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling addFulfillmentOptionToFulfillmentGroupUsingPUT1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (priceOrder !== undefined) {
            queryParameters = queryParameters.set('priceOrder', <any>priceOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.put<FulfillmentGroupWrapper>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/group/${encodeURIComponent(String(fulfillmentGroupId))}/option/${encodeURIComponent(String(fulfillmentOptionId))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * addItemToFulfillmentGroup
     * 
     * @param fulfillmentGroupId fulfillmentGroupId
     * @param wrapper wrapper
     * @param cartId cartId
     * @param priceOrder priceOrder
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addItemToFulfillmentGroupUsingPOST1(fulfillmentGroupId: number, wrapper: FulfillmentGroupItemWrapper, cartId: number, priceOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FulfillmentGroupWrapper>;
    public addItemToFulfillmentGroupUsingPOST1(fulfillmentGroupId: number, wrapper: FulfillmentGroupItemWrapper, cartId: number, priceOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FulfillmentGroupWrapper>>;
    public addItemToFulfillmentGroupUsingPOST1(fulfillmentGroupId: number, wrapper: FulfillmentGroupItemWrapper, cartId: number, priceOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FulfillmentGroupWrapper>>;
    public addItemToFulfillmentGroupUsingPOST1(fulfillmentGroupId: number, wrapper: FulfillmentGroupItemWrapper, cartId: number, priceOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fulfillmentGroupId === null || fulfillmentGroupId === undefined) {
            throw new Error('Required parameter fulfillmentGroupId was null or undefined when calling addItemToFulfillmentGroupUsingPOST1.');
        }
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling addItemToFulfillmentGroupUsingPOST1.');
        }
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling addItemToFulfillmentGroupUsingPOST1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (priceOrder !== undefined) {
            queryParameters = queryParameters.set('priceOrder', <any>priceOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<FulfillmentGroupWrapper>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/group/${encodeURIComponent(String(fulfillmentGroupId))}/item`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findFulfillmentGroupsForOrder
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findFulfillmentGroupsForOrderUsingGET1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentGroupWrapper>>;
    public findFulfillmentGroupsForOrderUsingGET1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentGroupWrapper>>>;
    public findFulfillmentGroupsForOrderUsingGET1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentGroupWrapper>>>;
    public findFulfillmentGroupsForOrderUsingGET1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling findFulfillmentGroupsForOrderUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FulfillmentGroupWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/groups`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findFulfillmentOptions
     * 
     * @param fulfillmentType fulfillmentType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findFulfillmentOptionsUsingGET1(fulfillmentType: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentOptionWrapper>>;
    public findFulfillmentOptionsUsingGET1(fulfillmentType: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentOptionWrapper>>>;
    public findFulfillmentOptionsUsingGET1(fulfillmentType: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentOptionWrapper>>>;
    public findFulfillmentOptionsUsingGET1(fulfillmentType: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fulfillmentType === null || fulfillmentType === undefined) {
            throw new Error('Required parameter fulfillmentType was null or undefined when calling findFulfillmentOptionsUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fulfillmentType !== undefined) {
            queryParameters = queryParameters.set('fulfillmentType', <any>fulfillmentType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FulfillmentOptionWrapper>>(`${this.basePath}/shipping/options`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFulfillmentEstimations
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFulfillmentEstimationsUsingDELETE1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentEstimationWrapper>>;
    public getFulfillmentEstimationsUsingDELETE1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingDELETE1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingDELETE1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getFulfillmentEstimationsUsingDELETE1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<Array<FulfillmentEstimationWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/estimate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFulfillmentEstimations
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFulfillmentEstimationsUsingGET1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentEstimationWrapper>>;
    public getFulfillmentEstimationsUsingGET1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingGET1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingGET1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getFulfillmentEstimationsUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<FulfillmentEstimationWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/estimate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFulfillmentEstimations
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFulfillmentEstimationsUsingHEAD1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentEstimationWrapper>>;
    public getFulfillmentEstimationsUsingHEAD1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingHEAD1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingHEAD1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getFulfillmentEstimationsUsingHEAD1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.head<Array<FulfillmentEstimationWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/estimate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFulfillmentEstimations
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFulfillmentEstimationsUsingOPTIONS1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentEstimationWrapper>>;
    public getFulfillmentEstimationsUsingOPTIONS1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingOPTIONS1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingOPTIONS1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getFulfillmentEstimationsUsingOPTIONS1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<Array<FulfillmentEstimationWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/estimate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFulfillmentEstimations
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFulfillmentEstimationsUsingPATCH1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentEstimationWrapper>>;
    public getFulfillmentEstimationsUsingPATCH1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingPATCH1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingPATCH1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getFulfillmentEstimationsUsingPATCH1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.patch<Array<FulfillmentEstimationWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/estimate`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFulfillmentEstimations
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFulfillmentEstimationsUsingPOST1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentEstimationWrapper>>;
    public getFulfillmentEstimationsUsingPOST1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingPOST1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingPOST1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getFulfillmentEstimationsUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Array<FulfillmentEstimationWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/estimate`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getFulfillmentEstimations
     * 
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFulfillmentEstimationsUsingPUT1(cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentEstimationWrapper>>;
    public getFulfillmentEstimationsUsingPUT1(cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingPUT1(cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentEstimationWrapper>>>;
    public getFulfillmentEstimationsUsingPUT1(cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getFulfillmentEstimationsUsingPUT1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.put<Array<FulfillmentEstimationWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/estimate`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeAllFulfillmentGroupsFromOrder
     * 
     * @param cartId cartId
     * @param priceOrder priceOrder
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAllFulfillmentGroupsFromOrderUsingDELETE1(cartId: number, priceOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<OrderWrapper>;
    public removeAllFulfillmentGroupsFromOrderUsingDELETE1(cartId: number, priceOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OrderWrapper>>;
    public removeAllFulfillmentGroupsFromOrderUsingDELETE1(cartId: number, priceOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OrderWrapper>>;
    public removeAllFulfillmentGroupsFromOrderUsingDELETE1(cartId: number, priceOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling removeAllFulfillmentGroupsFromOrderUsingDELETE1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (priceOrder !== undefined) {
            queryParameters = queryParameters.set('priceOrder', <any>priceOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<OrderWrapper>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/groups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeFulfillmentGroupFromOrder
     * 
     * @param fulfillmentGroupId fulfillmentGroupId
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeFulfillmentGroupFromOrderUsingDELETE1(fulfillmentGroupId: number, cartId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FulfillmentGroupWrapper>>;
    public removeFulfillmentGroupFromOrderUsingDELETE1(fulfillmentGroupId: number, cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FulfillmentGroupWrapper>>>;
    public removeFulfillmentGroupFromOrderUsingDELETE1(fulfillmentGroupId: number, cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FulfillmentGroupWrapper>>>;
    public removeFulfillmentGroupFromOrderUsingDELETE1(fulfillmentGroupId: number, cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fulfillmentGroupId === null || fulfillmentGroupId === undefined) {
            throw new Error('Required parameter fulfillmentGroupId was null or undefined when calling removeFulfillmentGroupFromOrderUsingDELETE1.');
        }
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling removeFulfillmentGroupFromOrderUsingDELETE1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<Array<FulfillmentGroupWrapper>>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/group/${encodeURIComponent(String(fulfillmentGroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * removeOrderItemFromFulfillmentGroup
     * 
     * @param fulfillmentGroupId fulfillmentGroupId
     * @param itemId itemId
     * @param cartId cartId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeOrderItemFromFulfillmentGroupUsingDELETE1(fulfillmentGroupId: number, itemId: number, cartId: number, observe?: 'body', reportProgress?: boolean): Observable<FulfillmentGroupWrapper>;
    public removeOrderItemFromFulfillmentGroupUsingDELETE1(fulfillmentGroupId: number, itemId: number, cartId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FulfillmentGroupWrapper>>;
    public removeOrderItemFromFulfillmentGroupUsingDELETE1(fulfillmentGroupId: number, itemId: number, cartId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FulfillmentGroupWrapper>>;
    public removeOrderItemFromFulfillmentGroupUsingDELETE1(fulfillmentGroupId: number, itemId: number, cartId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fulfillmentGroupId === null || fulfillmentGroupId === undefined) {
            throw new Error('Required parameter fulfillmentGroupId was null or undefined when calling removeOrderItemFromFulfillmentGroupUsingDELETE1.');
        }
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling removeOrderItemFromFulfillmentGroupUsingDELETE1.');
        }
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling removeOrderItemFromFulfillmentGroupUsingDELETE1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<FulfillmentGroupWrapper>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/group/${encodeURIComponent(String(fulfillmentGroupId))}/item/${encodeURIComponent(String(itemId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateFulfillmentGroupAddress
     * 
     * @param fulfillmentGroupId fulfillmentGroupId
     * @param cartId cartId
     * @param address address
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFulfillmentGroupAddressUsingPUT1(fulfillmentGroupId: number, cartId: number, address: AddressWrapper, observe?: 'body', reportProgress?: boolean): Observable<FulfillmentGroupWrapper>;
    public updateFulfillmentGroupAddressUsingPUT1(fulfillmentGroupId: number, cartId: number, address: AddressWrapper, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FulfillmentGroupWrapper>>;
    public updateFulfillmentGroupAddressUsingPUT1(fulfillmentGroupId: number, cartId: number, address: AddressWrapper, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FulfillmentGroupWrapper>>;
    public updateFulfillmentGroupAddressUsingPUT1(fulfillmentGroupId: number, cartId: number, address: AddressWrapper, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (fulfillmentGroupId === null || fulfillmentGroupId === undefined) {
            throw new Error('Required parameter fulfillmentGroupId was null or undefined when calling updateFulfillmentGroupAddressUsingPUT1.');
        }
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling updateFulfillmentGroupAddressUsingPUT1.');
        }
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling updateFulfillmentGroupAddressUsingPUT1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<FulfillmentGroupWrapper>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/${encodeURIComponent(String(fulfillmentGroupId))}/address`,
            address,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateFulfillmentGroup
     * 
     * @param wrapper wrapper
     * @param cartId cartId
     * @param fulfillmentGroupId fulfillmentGroupId
     * @param priceOrder priceOrder
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFulfillmentGroupUsingPATCH1(wrapper: FulfillmentGroupWrapper, cartId: number, fulfillmentGroupId: number, priceOrder?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FulfillmentGroupWrapper>;
    public updateFulfillmentGroupUsingPATCH1(wrapper: FulfillmentGroupWrapper, cartId: number, fulfillmentGroupId: number, priceOrder?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FulfillmentGroupWrapper>>;
    public updateFulfillmentGroupUsingPATCH1(wrapper: FulfillmentGroupWrapper, cartId: number, fulfillmentGroupId: number, priceOrder?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FulfillmentGroupWrapper>>;
    public updateFulfillmentGroupUsingPATCH1(wrapper: FulfillmentGroupWrapper, cartId: number, fulfillmentGroupId: number, priceOrder?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (wrapper === null || wrapper === undefined) {
            throw new Error('Required parameter wrapper was null or undefined when calling updateFulfillmentGroupUsingPATCH1.');
        }
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling updateFulfillmentGroupUsingPATCH1.');
        }
        if (fulfillmentGroupId === null || fulfillmentGroupId === undefined) {
            throw new Error('Required parameter fulfillmentGroupId was null or undefined when calling updateFulfillmentGroupUsingPATCH1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (priceOrder !== undefined) {
            queryParameters = queryParameters.set('priceOrder', <any>priceOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/xml',
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<FulfillmentGroupWrapper>(`${this.basePath}/shipping/${encodeURIComponent(String(cartId))}/group/${encodeURIComponent(String(fulfillmentGroupId))}`,
            wrapper,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
